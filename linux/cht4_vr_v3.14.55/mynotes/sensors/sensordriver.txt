sensor driver

create:   2016-11-14
modified: 

================================================================================
the file nodes:
shell@cht_vr:/sys/class/hwmon/hwmon3 $ ls device/                              
control
counter
data
data_size
debug
driver
fw_version
hwmon
modalias
power
profile_pull_control
profile_pull_data
status_mask
status_trig
trace
uevent

=>
相关属性文件的建立:
//hwmon/vr_sensor/psh_ia_common.c
(1)每个hwmon 设备都会有自己独有的属性，被 SENSOR_DEVICE_ATTR 声明为struct attribute结构体。
static SENSOR_DEVICE_ATTR(status_mask, S_IRUSR | S_IWUSR,
                          ia_get_status_mask, ia_set_status_mask, 0);
static SENSOR_DEVICE_ATTR(status_trig, S_IWUSR, NULL, ia_trig_get_status, 1);
static SENSOR_DEVICE_ATTR(debug, S_IRUSR | S_IWUSR,
                          ia_get_dbg_mask, ia_set_dbg_mask, 0);
static SENSOR_DEVICE_ATTR(control, S_IWUSR, NULL, ia_start_control, 1);
static SENSOR_DEVICE_ATTR(data_size, S_IRUSR, ia_read_data_size, NULL, 2);
static SENSOR_DEVICE_ATTR(counter, S_IWUSR | S_IRUSR, ia_get_counter,
                          ia_clear_counter, 0);


static struct bin_attribute bin_attr = {
	.attr = { .name = "data", .mode = S_IRUSR },
	.read = ia_read_data
};
static struct bin_attribute dbg_attr = {
	.attr = { .name = "trace", .mode = S_IRUSR },
	.read = ia_read_debug_data
};

(2) sysfs_create_files() create sysfs attribute file

static int create_sysfs_interface(struct device* dev)
{
    int ret_value;

    /*text part*/
	ret_value = sysfs_create_file(&dev->kobj,
                            &sensor_dev_attr_status_mask.dev_attr.attr);
   	ret_value += sysfs_create_file(&dev->kobj,
                             &sensor_dev_attr_status_trig.dev_attr.attr);
    ret_value += sysfs_create_file(&dev->kobj,
                             &sensor_dev_attr_debug.dev_attr.attr);
    ret_value += sysfs_create_file(&dev->kobj,
                             &sensor_dev_attr_control.dev_attr.attr);
    ret_value += sysfs_create_file(&dev->kobj,
                             &sensor_dev_attr_data_size.dev_attr.attr);
    ret_value += sysfs_create_file(&dev->kobj,
                             &sensor_dev_attr_counter.dev_attr.attr);
    ret_value += sysfs_create_file(&dev->kobj,
                             &sensor_dev_attr_fw_version.dev_attr.attr);

    /*binary part*/
    ret_value += sysfs_create_bin_file(&dev->kobj, &bin_attr);
    ret_value += sysfs_create_bin_file(&dev->kobj, &dbg_attr);

    return ret_value;
}
================================================================================
//psh_cht_spi.h
the key data structures

struct spi_io_context
{
#define SPI_IO_DUMMY_BUFFER_SIZE   16
    u8 send_dummy_buffer[SPI_IO_DUMMY_BUFFER_SIZE];
    u8 recv_dummy_buffer[SPI_IO_DUMMY_BUFFER_SIZE];

    u8 send_dummy_buffer_size;
    u8 recv_dummy_buffer_size;
};
#define INIT_SPI_IO_CONTEXT(x)  {(x)->send_dummy_buffer_size = sizeof((x)->send_dummy_buffer); \
                                 (x)->recv_dummy_buffer_size = sizeof((x)->recv_dummy_buffer);}


/*for quick-dirty, must refine after deadline*/

struct send_list_entry
{
    struct list_head list_entry;

#define MAX_SEND_DATA_SIZE 256
    u8 data[MAX_SEND_DATA_SIZE];
    int used_size;
    int debug_index;
};

struct send_list
{
    struct mutex lock;

    /*each one is a send_list_entry*/
    struct list_head head;

    struct spi_io_context low_spi_io_context;   
};

struct psh_ext_if
{
	struct device *hwmon_dev;
	struct spi_device *pshc;

	u8  psh_frame[LBUF_MAX_CELL_SIZE];

#define SEND_ZERO_SIZE  32
    u8 zero_send_buffer[SEND_ZERO_SIZE];

	int gpio_psh_ctl, gpio_psh_rst;
	int gpio_psh_int;

	int irq_disabled;
	
	struct workqueue_struct *wq;
	struct work_struct work;

#ifdef DRV_POLLING_MODE	
	struct delayed_work dwork;
    struct mutex workitem_mutex;
    int task_flag;
#endif 

    struct psh_ia_priv* ia_data;	

    struct send_list send_data_list;

    struct poller poller_worker;
    struct timestamp_item io_profiler;
};

//psh_ia_common.h
struct psh_ia_priv {

================================================================================
1.
	module_spi_driver(psh_vr_driver);
--  Helper macro for registering a SPI driver

static struct spi_driver psh_vr_driver = {
	.driver = {
		.name	= "vr-sensor-spi-ipc",
		.owner	= THIS_MODULE,
		.pm = &psh_byt_pm_ops, 
	},
	.probe		= psh_probe,
	.remove     = psh_remove,
	.shutdown	= psh_shutdown,
};

2. psh_probe 

static int psh_probe(struct spi_device *client)
|-- psh_if_info = kzalloc(sizeof(*psh_if_info), GFP_KERNEL);
|-- ret = psh_ia_common_init(&client->dev, &psh_if_info->ia_data);
|-- // initialize send list
    mutex_init(&psh_if_info->send_data_list.lock);
    mutex_init(&psh_if_info->workitem_mutex);
    INIT_LIST_HEAD(&psh_if_info->send_data_list.head);
|-- psh_if_info->hwmon_dev = hwmon_device_register(&client->dev);
	//register hwmon device
|-- psh_if_info->gpio_psh_ctl = -1;
|-- psh_if_info->gpio_psh_rst = GPIO_PSH_MCU_RESET;
	rc = gpio_request(psh_if_info->gpio_psh_rst, "psh_rst");
	gpio_export(psh_if_info->gpio_psh_rst, 1);
	gpio_direction_output(psh_if_info->gpio_psh_rst, 1);
	gpio_set_value(psh_if_info->gpio_psh_rst, 1);
|-- client->irq = -1; // force polling mode
	psh_if_info->gpio_psh_int = GPIO_PSH_INT;
	rc = gpio_request(psh_if_info->gpio_psh_int, "psh_int");
	gpio_export(psh_if_info->gpio_psh_int, 1);
	gpio_direction_input(psh_if_info->gpio_psh_int);
|-- psh_if_info->wq = alloc_workqueue("%s", WQ_HIGHPRI, 0, "psh_work");
|-- //just a profiler here
	timestamp_init_with_name(&client->dev, 
			&psh_if_info->io_profiler, "profile_pull");
	poller_init(&psh_if_info->poller_worker,
			poll_sensor_data_by_thread, psh_if_info);
    if (!IS_SUCCESS(poller_start(&client->dev,
                                 &psh_if_info->poller_worker)))
    ia_sync_timestamp_with_sensorhub_fw(psh_if_info->ia_data);
|-- INIT_WORK(&psh_if_info->work, psh_work_func); //not used ?
|-- INIT_DELAYED_WORK(&psh_if_info->dwork, poll_sensor_data);

--------------------------------------------------------------------------------
psh_work_func

--------------------------------------------------------------------------------
static void poll_sensor_data(struct work_struct *work)
|-- struct psh_ext_if *psh_if_info = 
		container_of(work, struct psh_ext_if, dwork.work);

|-- mutex_lock(&psh_if_info->workitem_mutex);
|-- poll_sensor_data_normal(psh_if_info);
|-- mutex_unlock(&psh_if_info->workitem_mutex);
|-- /*continue polling if necessary*/
    if (TASK_FLAG_REQUEST_LOOP & psh_if_info->task_flag)
    |-- queue_delayed_work(psh_if_info->wq, &psh_if_info->dwork, POLLING_HZ);


--------------------------------------------------------------------------------
poll_sensor_data_normal(psh_if_info);
|-- struct psh_ia_priv *ia_data = psh_if_info->ia_data;
	if(!ia_data)
		return;
|-- lp_send_entry = remove_send_data_entry_from_list(psh_if_info);    
	if (lp_send_entry) {
        lp_send = lp_send_entry->data;
        send_size = lp_send_entry->used_size;
	} else {
        lp_send = psh_if_info->zero_send_buffer;
        send_size = sizeof(psh_if_info->zero_send_buffer);
    }

|-- INIT_SPI_IO_CONTEXT(&psh_if_info->send_data_list.low_spi_io_context);
|-- ret_value = do_io_transaction(psh_if_info->pshc, 
						&psh_if_info->send_data_list.low_spi_io_context,
						lp_send, send_size,
						psh_if_info->psh_frame, sizeof(psh_if_info->psh_frame),
						&receved_size);


|-- if (IS_SUCCESS(ret_value))
        if (0 != receved_size)
			process_received_data(psh_if_info,
					psh_if_info->psh_frame, receved_size);
|-- /*finished, so clear resource*/
    if (lp_send_entry)
        kfree(lp_send_entry);

--------------------------------------------------------------------------------
queue_delayed_work(psh_if_info->wq, &psh_if_info->dwork, POLLING_HZ);

--------------------------------------------------------------------------------






