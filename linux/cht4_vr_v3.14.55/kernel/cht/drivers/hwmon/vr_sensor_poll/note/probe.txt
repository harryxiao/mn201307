
================================================================================
the file nodes:
shell@cht_vr:/sys/class/hwmon/hwmon3 $ ls device/                              
control
counter
data
data_size
debug
driver
fw_version
hwmon
modalias
power
profile_pull_control
profile_pull_data
status_mask
status_trig
trace
uevent

=>
相关属性文件的建立:
//hwmon/vr_sensor/psh_ia_common.c
(1)每个hwmon 设备都会有自己独有的属性，被 SENSOR_DEVICE_ATTR 声明为struct attribute结构体。
static SENSOR_DEVICE_ATTR(status_mask, S_IRUSR | S_IWUSR,
                          ia_get_status_mask, ia_set_status_mask, 0);
static SENSOR_DEVICE_ATTR(status_trig, S_IWUSR, NULL, ia_trig_get_status, 1);
static SENSOR_DEVICE_ATTR(debug, S_IRUSR | S_IWUSR,
                          ia_get_dbg_mask, ia_set_dbg_mask, 0);
static SENSOR_DEVICE_ATTR(control, S_IWUSR, NULL, ia_start_control, 1);
static SENSOR_DEVICE_ATTR(data_size, S_IRUSR, ia_read_data_size, NULL, 2);
static SENSOR_DEVICE_ATTR(counter, S_IWUSR | S_IRUSR, ia_get_counter,
                          ia_clear_counter, 0);


static struct bin_attribute bin_attr = {
	.attr = { .name = "data", .mode = S_IRUSR },
	.read = ia_read_data
};
static struct bin_attribute dbg_attr = {
	.attr = { .name = "trace", .mode = S_IRUSR },
	.read = ia_read_debug_data
};

(2) sysfs_create_files() create sysfs attribute file

static int create_sysfs_interface(struct device* dev)
{
    int ret_value;

    /*text part*/
	ret_value = sysfs_create_file(&dev->kobj,
                            &sensor_dev_attr_status_mask.dev_attr.attr);
   	ret_value += sysfs_create_file(&dev->kobj,
                             &sensor_dev_attr_status_trig.dev_attr.attr);
    ret_value += sysfs_create_file(&dev->kobj,
                             &sensor_dev_attr_debug.dev_attr.attr);
    ret_value += sysfs_create_file(&dev->kobj,
                             &sensor_dev_attr_control.dev_attr.attr);
    ret_value += sysfs_create_file(&dev->kobj,
                             &sensor_dev_attr_data_size.dev_attr.attr);
    ret_value += sysfs_create_file(&dev->kobj,
                             &sensor_dev_attr_counter.dev_attr.attr);
    ret_value += sysfs_create_file(&dev->kobj,
                             &sensor_dev_attr_fw_version.dev_attr.attr);

    /*binary part*/
    ret_value += sysfs_create_bin_file(&dev->kobj, &bin_attr);
    ret_value += sysfs_create_bin_file(&dev->kobj, &dbg_attr);

    return ret_value;
}
================================================================================
1.
	module_spi_driver(psh_vr_driver);
--  Helper macro for registering a SPI driver

static struct spi_driver psh_vr_driver = {
	.driver = {
		.name	= "vr-sensor-spi-ipc",
		.owner	= THIS_MODULE,
		.pm = &psh_byt_pm_ops, 
	},
	.probe		= psh_probe,
	.remove     = psh_remove,
	.shutdown	= psh_shutdown,
};

2. psh_probe 

static int psh_probe(struct spi_device *client)
(1) allocate memory for psh_ext_if
	<1> allocate memory for "struct psh_ext_if" which psh_if_info point to
|-- psh_if_info = kzalloc(sizeof(*psh_if_info), GFP_KERNEL);
	<2> cllocate memory for psh_ia_priv, and initialize the structure
|-- ret = psh_ia_common_init(&client->dev, &psh_if_info->ia_data);
			|-- (a) allocate memory for psh_ia_priv, and store such a pointer to
					psh_if_info->ia_data;
				(b) initialize psh_ia_priv structure,
					(mutex,completion,list_head, ..)
				(c) dev_set_drvdata(dev, psh_ia_data);
				(d) create sysfs interface: &dev->kobj
	<3> initialize its members about send list(mutex members and list_head member)
|-- // initialize send list
    mutex_init(&psh_if_info->send_data_list.lock);
    mutex_init(&psh_if_info->workitem_mutex);
    INIT_LIST_HEAD(&psh_if_info->send_data_list.head);
    psh_if_info->task_flag = TASK_FLAG_CLEAR;

(2) register w/ hwmon device
|-- psh_if_info->hwmon_dev = hwmon_device_register(&client->dev);
|-- psh_if_info->gpio_psh_ctl = -1;
|-- psh_if_info->gpio_psh_rst = GPIO_PSH_MCU_RESET;
	rc = gpio_request(psh_if_info->gpio_psh_rst, "psh_rst");
	gpio_export(psh_if_info->gpio_psh_rst, 1);
	gpio_direction_output(psh_if_info->gpio_psh_rst, 1);
	gpio_set_value(psh_if_info->gpio_psh_rst, 1);
|-- client->irq = -1; // force polling mode
	psh_if_info->gpio_psh_int = GPIO_PSH_INT;
	rc = gpio_request(psh_if_info->gpio_psh_int, "psh_int");
	gpio_export(psh_if_info->gpio_psh_int, 1);
	gpio_direction_input(psh_if_info->gpio_psh_int);
|-- psh_if_info->wq = alloc_workqueue("%s", WQ_HIGHPRI, 0, "psh_work");
|-- //just a profiler here
	timestamp_init_with_name(&client->dev, 
			&psh_if_info->io_profiler, "profile_pull");
	poller_init(&psh_if_info->poller_worker,
			poll_sensor_data_by_thread, psh_if_info);
    if (!IS_SUCCESS(poller_start(&client->dev,
                                 &psh_if_info->poller_worker)))
    ia_sync_timestamp_with_sensorhub_fw(psh_if_info->ia_data);
|-- INIT_WORK(&psh_if_info->work, psh_work_func); //not used ?
|-- INIT_DELAYED_WORK(&psh_if_info->dwork, poll_sensor_data);

--------------------------------------------------------------------------------
psh_work_func

--------------------------------------------------------------------------------
static void poll_sensor_data(struct work_struct *work)
|-- struct psh_ext_if *psh_if_info = 
		container_of(work, struct psh_ext_if, dwork.work);

|-- mutex_lock(&psh_if_info->workitem_mutex);
|-- poll_sensor_data_normal(psh_if_info);
|-- mutex_unlock(&psh_if_info->workitem_mutex);
|-- /*continue polling if necessary*/
    if (TASK_FLAG_REQUEST_LOOP & psh_if_info->task_flag)
    |-- queue_delayed_work(psh_if_info->wq, &psh_if_info->dwork, POLLING_HZ);


--------------------------------------------------------------------------------
poll_sensor_data_normal(psh_if_info);
|-- struct psh_ia_priv *ia_data = psh_if_info->ia_data;
	if(!ia_data)
		return;
|-- lp_send_entry = remove_send_data_entry_from_list(psh_if_info);    
	if (lp_send_entry) {
        lp_send = lp_send_entry->data;
        send_size = lp_send_entry->used_size;
	} else {
        lp_send = psh_if_info->zero_send_buffer;
        send_size = sizeof(psh_if_info->zero_send_buffer);
    }

|-- INIT_SPI_IO_CONTEXT(&psh_if_info->send_data_list.low_spi_io_context);
|-- ret_value = do_io_transaction(psh_if_info->pshc, 
						&psh_if_info->send_data_list.low_spi_io_context,
						lp_send, send_size,
						psh_if_info->psh_frame, sizeof(psh_if_info->psh_frame),
						&receved_size);


|-- if (IS_SUCCESS(ret_value))
        if (0 != receved_size)
			process_received_data(psh_if_info,
					psh_if_info->psh_frame, receved_size);
|-- /*finished, so clear resource*/
    if (lp_send_entry)
        kfree(lp_send_entry);

--------------------------------------------------------------------------------
queue_delayed_work(psh_if_info->wq, &psh_if_info->dwork, POLLING_HZ);

--------------------------------------------------------------------------------






